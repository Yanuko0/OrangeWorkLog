<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
</body>
<script>
    // //某執行平台下
    function algorithm(n) {
        var a = 2           // 1ns
        console.log(a)
        a = a + 1           // 1ns
        console.log(a)
        a = a * 2           // 1ns
        console.log(a)
        //迴圈 n 次
        for (let i = 0; i < n; i++) {     // 1ns
            console.log("執行了", i, "次")  // 5ns
        }
    }
    // console.log(algorithm(5))

    /*演算法 A 的時間複雜度: 常數階*/
    function algorithm_A(n) {
        console.log(n)
    }
    // console.log(algorithm_A(20))

    /*演算法 B 的時間複雜度: 線性階*/
    function algorithm_B(n) {
        for (let i = 0; i < n; i++) {
            console.log(n)
        }
    }
    // console.log(algorithm_B(1000))

    /*演算法 C 的時間複雜度: 線性階*/
    function algorithm_C(n) {
        for (let i = 0; i < 1000; i++) {
            console.log(n)
        }
    }
    // console.log(algorithm_C(10))

    /* 1.常數階O(1) */
    function constant(n) {
        let count = 0;
        const size = 10;
        for (let i = 0; i < size; i++) {
            count++;
            console.log(count)
        }
        return count;
    }
    // console.log(constant(10))

    /* 2.線性階O(n) */
    function linear(n) {
        let count = 0;
        for (let i = 0; i < n; i++) {
            count++;
            console.log(count)
        }
        return count;
    }
    // console.log(linear(10))

    /* 2-1.線性階(走訪陣列) */
    function arrayTraversal(nums) {
        let count = 0;
        for (let i = 0; i < nums.length; i++) {
            count++;
            console.log(count)
        }
        return count;
    }
    // console.log(arrayTraversal([1,2,3,4,5,6,7,8,9,10]))

    /* 平方階O(n的二次方)*/
    function quadratic(n) {
        let count = 0;
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                count++;
                console.log("i:", i, "j:", j, "count:", count)
            }
        }
        return count;
    }
    // console.log(quadratic(3))

    // i:0,j:0,count:1
    // i:0,j:1,count:2
    // i:0,j:2,count:3
    // i:1,j:0,count:4
    // i:1,j:1,count:5
    // i:1,j:2,count:6
    // i:2,j:0,count:7
    // i:2,j:1,count:8
    // i:2,j:2,count:9

    /* 平方階(泡沫排序) */
    function bubbleSort(nums) {
        //計數器
        let count = 0;
        //外迴圈: 未排序區間為[0, i]
        for (let i = nums.length - 1; i > 0; i--) {
            //內迴圈: 將未排序區間[0, i]中的最大元素交換至該區間的最右端
            for (let j = 0; j < i; j++) {
                if (nums[j] > nums[j + 1]) {
                    //交換 nums[j] 與 nums[j + 1]
                    let tmp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tmp;
                    count += 3; //元素包含 3格單位操作

                }
                console.log(
                    "i:", i, "j:", j,
                    "nums[j]:", nums[j], "nums[j+1]:", nums[j + 1],
                    "count:", count)
            }
        }
        return count;
    }
    // console.log(bubbleSort([1,2,4,5,3]))

    // i:4,j:0,nums[j] > nums[j + 1]:1 < 2,count = 0
    // i:4,j:1,nums[j] > nums[j + 1]:2 < 4,count = 0
    // i:4,j:2,nums[j] > nums[j + 1]:4 < 5,count = 0
    // i:4,j:3,nums[j] > nums[j + 1]:5 > 3,count = 3 變成[1,2,4,3,5]
    // i:3,j:0,nums[j] > nums[j + 1]:1 < 2,count = 3
    // i:3,j:1,nums[j] > nums[j + 1]:2 < 4,count = 3
    // i:3,j:2,nums[j] > nums[j + 1]:4 > 3,count = 6 變成[1,2,3,4,5]
    // i:2,j:0,nums[j] > nums[j + 1]:1 < 2,count = 6 
    // i:2,j:1,nums[j] > nums[j + 1]:2 < 3,count = 6 
    // i:1,j:0,nums[j] > nums[j + 1]:1 < 2,count = 6 
    // i:0,j:0,nums[j] > nums[j + 1]:1 < 2,count = 6  不執行 因為i要>0

    // console.log(bubbleSort([7,2,4,3]))
    // i:3,j:0,nums[j] > nums[j + 1]:7 > 2,count = 3 變成[2,7,4,3]
    // i:3,j:1,nums[j] > nums[j + 1]:7 > 4,count = 6 變成[2,4,7,3]
    // i:3,j:2,nums[j] > nums[j + 1]:7 > 3,count = 9 變成[2,4,3,7]
    // i:2,j:0,nums[j] > nums[j + 1]:2 < 4,count = 9 
    // i:2,j:1,nums[j] > nums[j + 1]:4 > 3,count = 12 變成[2,3,4,7] 
    // i:1,j:0,nums[j] > nums[j + 1]:2 < 3,count = 12 

    /*指數階O(2的n次方)*/
    function exponential(n) {
        let count = 0, base = 1;
        //細胞每輪一分為二, 形成數列 1, 2, 4, 8, ..., 2^(n-1)
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < base; j++) {
                count++;
                console.log("i:", i, "j:", j, "base:", base, "count:", count)
            }
            base *= 2;
            console.log("base變為:", base)
        }
        return count;
    }

    // console.log(exponential(1))
    // i:0 , j:0 , base: 1, count:1
    // base變為2
    // count 為 1

    // console.log(exponential(2))
    // i:0 , j:0 , base: 1, count:1
    // base變為2
    // i:1 , j:0 , base: 2, count:2
    // i:1 , j:1 , base: 2, count:3
    // base變為4
    // count 為 3

    // console.log(exponential(3))
    // i:0 , j:0 , base: 1, count:1
    // base變為2
    // i:1 , j:0 , base: 2, count:2
    // i:1 , j:1 , base: 2, count:3
    // base變為4
    // i:2 , j:0 , base: 4, count:4
    // i:2 , j:1 , base: 4, count:5
    // i:2 , j:2 , base: 4, count:6
    // i:2 , j:3 , base: 4, count:7
    // base變為8
    // count 為 7

    // console.log(exponential(4))
    // i:0 , j:0 , base: 1, count:1
    // base變為2
    // i:1 , j:0 , base: 2, count:2
    // i:1 , j:1 , base: 2, count:3
    // base變為4
    // i:2 , j:0 , base: 4, count:4
    // i:2 , j:1 , base: 4, count:5
    // i:2 , j:2 , base: 4, count:6
    // i:2 , j:3 , base: 4, count:7
    // base變為8
    // i:3 , j:0 , base: 8, count:8
    // i:3 , j:1 , base: 8, count:9
    // i:3 , j:2 , base: 8, count:10
    // i:3 , j:3 , base: 8, count:11
    // i:3 , j:4 , base: 8, count:12
    // i:3 , j:5 , base: 8, count:13
    // i:3 , j:6 , base: 8, count:14
    // i:3 , j:7 , base: 8, count:15
    // base變為16
    // i:4 不符合
    // count 為 15

    /*指數階(遞迴實現)*/
    function expRecur(n) {
        if (n === 1) return 1;
        return expRecur(n - 1) + expRecur(n - 1) + 1;
    }
    // console.log(expRecur(5))
    // expRecur(5) = expRecur(4) + expRecur(4) + 1 = 2(expRecur(4)) + 1 
    // 2(expRecur(3) + expRecur(3) + 1) + 1 = 4(expRecur(3)) + 2 + 1
    // 4(expRecur(2) + expRecur(2) + 1) + 2 + 1 =
    // 8(expRecur(2)) + 4 + 2 + 1 =
    // 8(expRecur(1) + expRecur(1) + 1) + 4 + 2 + 1= 
    // 16(expRecur(1)) + 8 + 4 + 2 + 1
    // 16 * 1 + 8 + 4 + 2 + 1 = 31

    /* 對數階O(log n) */
    function logarithmic(n) {
        let count = 0;
        while (n > 1) {
            n = n / 2;
            count++
            console.log("n", n, "count", count)
        }
        return count;
    }
    // console.log(logarithmic(10))
    // n:5, count:1,
    // n:2.5, count:2,
    // n:1.25, count:3,
    // n:0.625, count:4,

    /* 對數階(遞迴實現) */
    function logRecur(n) {
        if (n <= 1) return 0;
        return logRecur(n / 2) + 1;
    }
    // console.log(logRecur(10))
    // logRecur(5) + 1 = logRecur(2.5) + 1 + 1 =
    // logRecur(1.25) + 1 + 1 + 1 =
    // logRecur(0.625) + 1 + 1 + 1 + 1  = 0 + 4 

    /* 線性對數階 O(n log n ) */
    function linearLogRecur(n) {
        if (n <= 1) return 1;
        let count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
        console.log("count", count)
        for (let i = 0; i < n; i++) {
            count++;
            console.log("i", i, "n", n, "加過的count", count)
        }
        return count;
    }
    // console.log(linearLogRecur(3))
    // linearLogRecur(3): 
    // count = linearLogRecur(1.5) + linearLogRecur(1.5)
    // i:0, n:3, count + 1
    // i:1, n:3, count + 1 + 1
    // i:2, n:3, count + 1 + 1 + 1
    // 變成 2(linearLogRecur(1.5)) + 3
    //linearLogRecur(1.5) = linearLogRecur(0.75) + linearLogRecur(0.75)
    // i:0, n:1.5, count + 1
    // i:1, n:1.5, count + 1 + 1
    // 變成 2(2(linearLogRecur(0.75) + 2)) + 3
    // 變成2(2*1 + 2) + 3 = 2*4+3 = 11

    /* 階乘階O(n!) */
    function factorialRecur(n) {
        if (n === 0) return 1;
        let count = 0;
        // 從1個分裂出n個
        for (let i = 0; i < n; i++) {
            count += factorialRecur(n - 1);
            console.log("i:", i, "n", n, "count:", count)
        }
        return count;
    }
    // console.log(factorialRecur(3))
    //factorialRecur(3):
    // i:0 , n:3, count: 0 + factorialRecur(2)
    // i:1 , n:3, count: factorialRecur(2) + factorialRecur(2)
    // i:2 , n:3, count: factorialRecur(2) + factorialRecur(2) + factorialRecur(2)
    // = 3(factorialRecur(2)) =
    // i:0 , n:2, count: 0 + factorialRecur(1)
    // i:1 , n:2, count: 0 + factorialRecur(1) + factorialRecur(1)
    // = 3(2(factorialRecur(1)))
    // i:0 , n:1, count: 0 + factorialRecur(0) = 1
    // = 3(2(1)) = 6

    /* 生成一個陣列, 元素為{1,2,...,n},順序被打亂 */
    function randomNumbers(n) {
        const nums = Array(n);
        //生成陣列 nums = { 1, 2, 3, ..., n }
        for(let i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        //隨機打亂陣列元素
        for(let i = 0; i < n; i++) {
            const r = Math.floor(Math.random() * (i + 1));
            const temp = nums[i];
            nums[i] = nums[r];
            nums[r] = temp;
        }
        return nums;
    }
//randomNumbers(10)

    /* 查詢陣列 nums 中數字 1 所在索引*/
    function findOne(nums) {
        for(let i = 0; i < nums.length; i++) {
            //當元素 1 在陣列頭部時, 達到最佳時間複雜度 O(1)
            //當元素 1 在陣列尾部時, 達到最差時間複雜度 O(n)
            if(nums[i] === 1) {
                return i;
            }
        }
        return -1;
    }

    //生成一個亂的陣列
    const newArry = randomNumbers(10)
    //找到陣列中的數字1的位置
    console.log("陣列:",newArry,"數字1位置:",findOne(newArry))




</script>

</html>